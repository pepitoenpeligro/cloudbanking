# R1 Frameworks

As usual, the entire learning process is discussed in the respective issues of this repository. About the chosen frameworks can be found in [issue #70](https://github.com/pepitoenpeligro/cloudbanking/issues/70)

To achieve the widest possible coverage, four microservices have been implemented using different frameworks in different languages (polyglot property of the microservices):

![](img/microservices-framework-graphic.png)

We are going to detail below, which frameworks we have valued, which qualities they offer us, which disadvantages and which final reasons have motivated me to use or discard them.



## Rust


1. [Hyper](https://crates.io/crates/hyper)
2. [Burner](https://crates.io/crates/burner)
3. [Trek-router](https://crates.io/crates/trek-router)
4. [Resty](https://crates.io/crates/resty)
5. [Rocket](https://rocket.rs)
6. [Warp](https://crates.io/crates/warp)
7. [Actix](https://crates.io/crates/actix-web)

##### Hyper

1. ğŸ‘  It's low-level library (not framework).
2. ğŸ‘  It's the basic library for [warp](https://github.com/seanmonstar/warp) and [reqwest](https://github.com/seanmonstar/reqwest)
3. ğŸ‘ It has a Asynchronous design
4. ğŸ‘ It has been tested
5. ğŸ‘ Extensive production use
6. ğŸ‘ Leading in performance
7. ğŸ‘ Low Crate Size: 142 kB
8. ğŸ‘ Open Source: MIT License
9. ğŸ‘ No native JSON support.
10. ğŸ‘ Last update: 3 months ago


```rust
use std::convert::Infallible;

use hyper::service::{make_service_fn, service_fn};
use hyper::{Body, Request, Response, Server};

async fn hello(_: Request<Body>) -> Result<Response<Body>, Infallible> {
    Ok(Response::new(Body::from("Hi Cloudbanking")))
}

#[tokio::main]
pub async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    pretty_env_logger::init();

    let handler_service = make_service_fn(|_conn| {
        async { Ok::<_, Infallible>(service_fn(hello)) }
    });

    let host_port = ([0,0,0,0], 8080).into();

    let server = Server::bind(&host_port).serve(handler_service);

    println!("Listening on http://{}", host_port);

    server.await?;

    Ok(())
}
```


##### Burner

ğŸ‘  It's a express (nodejs) based framework. 
ğŸ‘ Last update: 6 months ago
ğŸ‘ No native JSON support.


```rust
extern crate burner;

use burner::{Server, Request, Response, RouterService};
let mut server = Server::new();

let handler = |req: &Request, res: &mut Response| {
	res.status(200);
};

let path = "/api";
server.get(path, Box::new(handler));


server.listen(8080);
```



##### Trek-Router


1. ğŸ‘ Supports get, post delete, patch, put, options, head, connect and trace
2. ğŸ‘ Supports any for above APIs
3. ğŸ‘ Supports scope for scope routes
4. ğŸ‘ High Crate Size: 965 kB
5. ğŸ‘ No native JSON support
6. ğŸ‘ Poor documentation. No examples


```rust
let addr = ([127, 0, 0, 1], 3000).into();

    let mut router = Router::<Handler>::new();

    router

        .scope("/api1", |api1| {
            api1.get("/login", api1_login)
                .post("/submit", api1_submit)
                .delete("/read", api1_read);
        })
        .scope("/api2", |api2| {
            api2.get("/login", api2_login)
                .post("/submit", api2_submit)
                .delete("/read", api2_read)
                .scope("users", |u| {
                    u.any("", users);
                });
        })
        .get("/products", products)
        .post("/product", product)
        .delete("/product", product);
```



##### Resty


1. ğŸ‘ It's JSON based
2. ğŸ‘ High Crate Size: 754 kB
3. ğŸ‘ Last Updated 3 years ago


```rust 
fn main() {
    let mut server = resty::Router::new();
    server.get("/", |_| {
        Ok("Welcome!!")
    });
    server.post("/api", |request| {
        request.json().map(|mut call: Call| {
            response
        })
    });

    let listening = server.bind("localhost:3000").unwrap();
    listening.wait()
}
```

##### Rocket


Rocket is a web **framework** for Rust that makes it simple to write fast secure web applications and type safe.

ğŸ‘ It's type safe
ğŸ‘ With Config Environments
ğŸ‘ With Testing Library for API
ğŸ‘ With Typed URIs
ğŸ‘ Large Community
ğŸ‘ ğŸ‘ ğŸ‘  Only supported by nightly version of Rust.



```rust
#![feature(proc_macro_hygiene, decl_macro)]

#[macro_use] extern crate rocket;

#[get("/hello/<name>/<age>")]
fn hello(name: String, age: u8) -> String {
    format!("Hello, {} year old named {}!", age, name)
}

fn main() {
    rocket::ignite().mount("/", routes![hello]).launch();
}
```

##### Warp

https://crates.io/crates/warp

It's a super-easy, composable, web server framework. Build over *hyper*.

ğŸ‘ Path routing and parameter extraction
ğŸ‘ Header requirements and extraction
ğŸ‘ Query string deserialization
ğŸ‘ JSON and Form bodies
ğŸ‘ Multipart form data
ğŸ‘ Static Files and Directories
ğŸ‘ Websockets
ğŸ‘ Access logging
ğŸ‘ Gzip and Deflate compression
ğŸ‘ 111kB
ğŸ‘ Updated every 2 months



```rust
use warp::{Filter};

mod song;
mod json;

use crate::song::model::{Store};
use crate::song::handler::{update_list_handler,get_list_handler,delete_list_handler};
use crate::json::helpers::{post_json,delete_json};


#[tokio::main]
async fn main() {
    let store = Store::new();
    let store_filter = warp::any().map(move || store.clone());

    let add_items = warp::post()
        .and(warp::path("songs"))
        .and(warp::path::end()).and(post_json())
        .and(store_filter.clone())
        .and_then(update_list_handler);

    let get_items = warp::get()
        .and(warp::path("songs"))
        .and(warp::path::end())
        .and(store_filter.clone())
        .and_then(get_list_handler);

    let delete_item = warp::delete()
        .and(warp::path("songs"))
        .and(warp::path::end())
        .and(delete_json())
        .and(store_filter.clone())
        .and_then(delete_list_handler);

    let update_item = warp::put()
        .and(warp::path("songs"))
        .and(warp::path::end())
        .and(post_json())
        .and(store_filter.clone())
        .and_then(update_list_handler);

    let routes = add_items.or(get_items).or(delete_item).or(update_item);

    warp::serve(routes)
        .run(([0, 0, 0, 0], 8000))
        .await;
}
```


Complete example can be found here: https://github.com/pepitoenpeligro/music_store


##### Actix


ğŸ‘ Supports HTTP/1.x and HTTP/2
ğŸ‘ Streaming and pipelining
ğŸ‘ Keep-alive and slow requests handling
ğŸ‘ Client/server WebSockets support
ğŸ‘ Transparent content compression/decompression (br, gzip, deflate)
ğŸ‘ Powerful request routing
ğŸ‘ Multipart streams
ğŸ‘ Static assets
ğŸ‘ SSL support using OpenSSL or Rustls
ğŸ‘ Middlewares (Logger, Session, CORS, etc)
ğŸ‘ Includes an async HTTP client
ğŸ‘ Supports Actix actor framework
ğŸ‘ Runs on stable Rust 1.42+
ğŸ‘ Low Size: 134 kB
ğŸ‘ Last Updated: 18 days ago


```rust
use actix_web::{get, web, App, HttpServer, Responder};

#[get("/{id}/{name}/index.html")]
async fn index(web::Path((id, name)): web::Path<(u32, String)>) -> impl Responder {
    format!("Hello {}! id:{}", name, id)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| App::new().service(index))
        .bind("127.0.0.1:8080")?
        .run()
        .await
}
```

Without a doubt, the most attractive frameworks are:
1. Rocket
2. Warp
3. Actix

Because they are fast, robust, reliable, have native json support, low weight, with a future (http 2 support), with large developer communities behind them and with good documentation.

Of all of them we discarded Rocket as it is not yet on the stable Rust channel (it is only on the nightly channel).





## Nim


##### Nawak

1. ğŸ‘ Express-style
2. Poor documentation
3. ğŸ‘ No native JSON support



```nim
import nawak_mongrel, strutils

get "/":
    return response("Hi Cloudbanking!")

get "/api/@userid/?":
    return response("Welcomeback $1!" % url_params.username)

run()
```

##### Jester

1. ğŸ‘ Supports HTTP/1.x and HTTP/2
2. ğŸ‘ Keep-alive and slow requests handling
3. ğŸ‘ Client/server WebSockets support
4. ğŸ‘ Transparent content compression/decompression (br, gzip, deflate)
5. ğŸ‘ Powerful request routing
6. ğŸ‘ Includes an async HTTP client
7. ğŸ‘ Well documented


```nim
import json
import dotenv, os
import asyncdispatch, jester, strutils
import logging
import etcd_client
include ./jester_cards/controller

let  logger = newConsoleLogger()
let etcdClientObj = new_etcd_client(failover=false)

proc messageJson(msg: string): string =
  """{"msg": $#}""" % [msg]


let controller = CardController(bankCards: TableRef[string, Card]() )

router cloudbankingCardsRoutes:

  # Get a bank card by id
  get "/cards/@id":
    info("[GET] /cards/{id}")
    let paramReceived = @"id"
    let recoveredCard = controller.getBankCard(paramReceived)
    let idField = "" & recoveredCard.id;
    if idField == "-":
      error("Card not founded")
      resp(Http200, messageJson("Card not founded" & $(recoveredCard)), contentType="application/json")

    info("Card founded")
    resp(Http404, messageJson("Card founded: " & $(recoveredCard)), contentType="application/json")


proc main() =
  var port:string = ""
  try:
    port = $etcdClientObj.get("PORT")
  except:
    echo("Could not found ETCD server")
  finally:
    echo("We are reading values from .env")
    let env = initDotEnv()
    env.load()

    port = os.getEnv("PORT")
    let settings = newSettings(port=port.parseInt().Port)
    var jester = initJester(cloudbankingCardsRoutes, settings=settings)
    jester.serve()

when isMainModule:
  main()
```

It is quite clear, that our favourite is: **Jester**

## Kotlin

##### Spring


1. ğŸ‘ Huge community
2. ğŸ‘ Same structure as Java Spring
3. ğŸ‘ Client/server WebSockets support
4. ğŸ‘ Powerful request routing
5. ğŸ‘ Includes an async HTTP client
6. ğŸ‘ Well documented

```kotlin
@RestController
class CloudBankingController {

    @GetMapping("/api/users")
    fun welcome() name: String) =
           Response.ok().entity("hi").build()

}
```



##### Vert.x

1. ğŸ‘ Client/server WebSockets support
2. ğŸ‘ Powerful request routing
3. ğŸ‘ Poor community

```kotlin
import io.vertx.core.AbstractVerticle

class Server : AbstractVerticle() {
  override fun start() {
    vertx.createHttpServer().requestHandler { req ->
      req.response()
        .putHeader("content-type", "text/plain")
        .end("Hello cloudbanking!")
    }.listen(8080)
  }
}
```


##### Javalin

1. ğŸ‘ Jetty based. Lightweight
2. ğŸ‘ Simple and Interoperable
3. ğŸ‘ Poor community
4. ğŸ‘ Poor documentation

```kotlin
import io.javalin.Javalin

fun main(args: Array<String>) {
    val app = Javalin.create().start(8080)
    app.get("/") { ctx -> ctx.result("Hi cloudbanking") }
}
```


##### Quarkus

1. ğŸ‘ Huge community
2. ğŸ‘ Based in GraalVM (low ram-figerprint)
3. ğŸ‘ Client/server WebSockets support
4. ğŸ‘ Powerful request routing
5. ğŸ‘ Includes an async HTTP client
6. ğŸ‘ Well documented

7. ğŸ‘ Container-first
8. ğŸ‘ Quarkus builds applications to consume 1/10th the memory when compared to traditional Java, and has a faster startup time (as much as 300 times faster
9. ğŸ‘ Quarkus applications can start in under .0015 seconds, making it possible to use the existing Spring and Java API knowledge with FaaS functions. (Azure, AWS Lambda).
10. ğŸ‘ Support for reactive and imperative model.
11. ğŸ‘ Early detection of dependency injection errors. Quarkus catches dependency injection errors during compilation instead of at runtime.
12. ğŸ‘ Use best of breed frameworks and standards together. Quarkus supports Spring API compatibility, Eclipse Vert.x, MicroProfile (JAX-RS, CDI, etc), reactive streams and messaging, and more in the same application

```kotlin
package com.pepe.rest.resteasyjackson

import java.util.*
import javax.ws.rs.*
import javax.ws.rs.core.MediaType

@Path("/resteasy-jackson/quarks")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
class JacksonResource {

    private val quarks = Collections.newSetFromMap(Collections.synchronizedMap(LinkedHashMap<Quark, Boolean>()))

    init {
        quarks.add(Quark("Up", "The up quark or u quark (symbol: u) is the lightest of all quarks, a type of elementary particle, and a major constituent of matter."))
        quarks.add(Quark("Strange", "The strange quark or s quark (from its symbol, s) is the third lightest of all quarks, a type of elementary particle."))
        quarks.add(Quark("Charm", "The charm quark, charmed quark or c quark (from its symbol, c) is the third most massive of all quarks, a type of elementary particle."))
        quarks.add(Quark("???", null))
    }

    @GET
    fun list(): Set<Quark> {
        return quarks
    }

    @POST
    fun add(quark: Quark): Set<Quark> {
        quarks.add(quark)
        return quarks
    }

    @DELETE
    fun delete(quark: Quark): Set<Quark> {
        quarks.removeIf { existingQuark: Quark -> existingQuark.name!!.contentEquals(quark.name!!) }
        return quarks
    }

    class Quark {
        var name: String? = null
        var description: String? = null

        constructor() {}
        constructor(name: String?, description: String?) {
            this.name = name
            this.description = description
        }
    }
}
```

Any option could be interesting, but of all of them, the most promising is Quarkus. Let's give it a try!


### References

1. [Choosing a Rust Web Framework in 2020](https://www.lpalmieri.com/posts/2020-07-04-choosing-a-rust-web-framework-2020-edition/)
2. [Hyper](https://crates.io/crates/hyper)
3. [Burner](https://crates.io/crates/burner)
3. [Trek Router](https://crates.io/crates/trek-router)
4. [Resty](https://crates.io/crates/resty)
5. [Rocket](https://rocket.rs)
6. [Warp](https://crates.io/crates/warp)
7. [Actix](https://crates.io/crates/actix-web)
8. [Nawak](https://github.com/idlewan/nawak)
9. [Jester](https://github.com/dom96/jester)
10. [Spring](https://spring.io/guides/tutorials/spring-boot-kotlin/)
11. [Quarkus RedHat](https://www.redhat.com/en/topics/cloud-native-apps/what-is-quarkus)
12. [Quarkus vs Spring](https://quarkus.io/blog/quarkus-for-spring-developers/)
